#include "Network.h"
#include "kernel.h" // TODO: BETA -> config.h

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <vector>


// Return: real batch size
int get_batch_data(std::ifstream &ist, 
                   std::vector<int> &h_c_input_nodes,
                   std::vector<float> &h_c_input_vals,
                   std::vector<int> &h_c_input_cols,
                   std::vector<int> &h_c_labels,
                   std::vector<int> &h_c_label_cols,
                   const int batch_size)
{
    h_c_input_nodes.clear();
    h_c_input_vals.clear();
    h_c_input_cols.clear();
    h_c_labels.clear();
    h_c_label_cols.clear();

    h_c_input_cols.push_back(0);
    h_c_label_cols.push_back(0);

    for (int b = 0; b < batch_size; ++b) {
        int label;
        if (ist >> label) {
            h_c_labels.push_back(label);
        } else {
            return b;
        }

        while (ist.get() == ',') {
            ist >> label;
            h_c_labels.push_back(label);
        }
        h_c_label_cols.push_back(h_c_labels.size());

        do {
            int node;
            ist >> node;
            assert(ist.get() == ':');
            
            float val;
            ist >> val;
            h_c_input_nodes.push_back(node);
            h_c_input_vals.push_back(val);
        } while (ist.get() == ' ');
        h_c_input_cols.push_back(h_c_input_nodes.size());
    }

    return batch_size;
}


int main(int argc, char *argv[]) {
    const std::vector<int> node_num_per_layer = { 128, 670091 };
    const std::vector<int> node_capacity_per_layer = { 128 * 128, 5120 * 128};
    const int input_size = 135909;
    const int max_batch_size = 128;
    const int input_capacity = 128 * 128;
    const int label_capacity = 32 * 128;
    const int K = 6, L = 50;
    const int bin_size = 8;
    const int pack_num = 4;
    const int tbl_bucket_num = 1 << 14;
    const int bucket_unit_size = 128;
    const int tbl_capacity = L * bucket_unit_size * 2;

    Network network(node_num_per_layer, node_capacity_per_layer, input_size,
        max_batch_size, input_capacity, label_capacity, K, L, bin_size, pack_num,
        tbl_bucket_num, bucket_unit_size, tbl_capacity);
    
    const std::vector<int> max_act_nums = { 128, 5120 };
    const int max_label_num = 32;
    const float lr = 0.0001;
    const float BETA1 = 0.9, BETA2 = 0.999;
    const int thread_num = 128;

    GPUTimer timer;
    float tot_time = 0;

    const int epoch_num = 10;
    for (int e = 0; e < epoch_num; e++) {
        printf("------------------- Epoch %d ---------------------\n", e);
        std::ifstream ist("dataset/Amazon/amazon_train.txt");
        std::ifstream testIst("dataset/Amazon/amazon_test.txt");
        if (!ist || !testIst) {
            std::cerr << "Cannot open dataset file!" << std::endl;
            exit(-1);
        }

        std::string header;
        std::getline(ist, header); // skip header
        std::getline(testIst, header); // skip header

        int batch_size;
        int cnt = 0;
        do {
            std::vector<int> h_c_input_nodes;
            std::vector<float> h_c_input_vals;
            std::vector<int> h_c_input_cols;
            std::vector<int> h_c_labels;
            std::vector<int> h_c_label_cols;
            batch_size = get_batch_data(ist,
                h_c_input_nodes, h_c_input_vals, h_c_input_cols,
                h_c_labels, h_c_label_cols, max_batch_size);
            
            const float tmplr = 
                lr * sqrt((1 - pow(BETA2, cnt + 1))) / (1 - pow(BETA1, cnt + 1));
            const bool rebuild = cnt % 5 == 4;

            timer.start();
            
            network.train(h_c_input_nodes, h_c_input_vals, h_c_input_cols,
                h_c_labels, h_c_label_cols, max_act_nums, batch_size, tmplr,
                max_label_num, thread_num, rebuild);

            tot_time += timer.record("[BATCH " + std::to_string(cnt) + "] ");
            
            cnt++;
            // if (cnt > 10) break;

        } while (batch_size == max_batch_size);
        network.rebuild();

        printf("Current elapsed time %f ms\n", tot_time);

        // eval
        int correct_cnt = 0, test_cnt = 0;
        do {
            std::vector<int> h_c_input_nodes;
            std::vector<float> h_c_input_vals;
            std::vector<int> h_c_input_cols;
            std::vector<int> h_c_labels;
            std::vector<int> h_c_label_cols;
            batch_size = get_batch_data(testIst,
                h_c_input_nodes, h_c_input_vals, h_c_input_cols,
                h_c_labels, h_c_label_cols, max_batch_size);

            timer.start();

            correct_cnt += 
                network.eval(h_c_input_nodes, h_c_input_vals, h_c_input_cols,
                    h_c_labels, h_c_label_cols, batch_size, thread_num);
            
            // timer.record("Infer time ");

            test_cnt += batch_size;
            // if (test_cnt >= 512) break;

        } while (batch_size == max_batch_size);

        printf("Test %d records, %d correct; accuracy: %f\n",
            test_cnt, correct_cnt, ((float) correct_cnt) / test_cnt);
    }
}
